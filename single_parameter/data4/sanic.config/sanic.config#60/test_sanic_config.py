# Test cases automatically generated by Pynguin (https://www.pynguin.eu).
# Please check them before you use them.
import sanic.config as module_0
import sanic.http.http1 as module_1
import inspect as module_2


def test_case_0():
    config_0 = module_0.Config()


def test_case_1():
    str_0 = "P"
    config_0 = module_0.Config(env_prefix=str_0, keep_alive=str_0)
    none_type_0 = config_0.update()
    none_type_1 = config_0.register_type(str_0)


def test_case_2():
    str_0 = "HNo}\x0b0qaDz[\n\r/):<@\nd"
    module_0.Config(str_0, keep_alive=str_0)


def test_case_3():
    none_type_0 = None
    config_0 = module_0.Config(none_type_0, converters=none_type_0)
    config_0.update_config(none_type_0)


def test_case_4():
    config_0 = module_0.Config()
    none_type_0 = config_0.update_config(config_0)


def test_case_5():
    config_0 = module_0.Config()
    none_type_0 = None
    none_type_1 = config_0.register_type(none_type_0)
    config_0.update_config(none_type_1)


def test_case_6():
    int_0 = -107
    module_0.Config(env_prefix=int_0, converters=int_0)


def test_case_7():
    str_0 = "P"
    config_0 = module_0.Config(env_prefix=str_0, keep_alive=str_0)
    module_1.Http(config_0)


def test_case_8():
    str_0 = "R!Zo5>W7D.#71yS%\t/P"
    str_1 = "+"
    dict_0 = {str_0: str_0, str_1: str_0}
    config_0 = module_0.Config()
    none_type_0 = config_0.update(**dict_0)
    config_0.update_config(str_1)


def test_case_9():
    config_0 = module_0.Config()
    none_type_0 = config_0.update(**config_0)
    none_type_1 = None
    config_1 = module_0.Config(env_prefix=none_type_1)
    none_type_2 = config_0.register_type(none_type_1)
    config_0.init_for_request()


def test_case_10():
    str_0 = "R!Zo5>W7D.#71yS%\t/P"
    str_1 = "P"
    var_0 = module_2.isdatadescriptor(str_0)
    config_0 = module_0.Config(env_prefix=str_1, keep_alive=var_0)
    var_1 = config_0.update_config(config_0)
    module_0.Config(env_prefix=str_1, converters=config_0)


def test_case_11():
    config_0 = module_0.Config()
    config_0.__getattr__(config_0)


def test_case_12():
    str_0 = "\n        Receive the next message.\n        Return a :class:`str` for a text frame and :class:`bytes` for a binary\n        frame.\n        When the end of the message stream is reached, :meth:`recv` raises\n        :exc:`~websockets.exceptions.ConnectionClosed`. Specifically, it\n        raises :exc:`~websockets.exceptions.ConnectionClosedOK` after a normal\n        connection closure and\n        :exc:`~websockets.exceptions.ConnectionClosedError` after a protocol\n        error or a network failure.\n        If ``timeout`` is ``None``, block until a message is received. Else,\n        if no message is received within ``timeout`` seconds, return ``None``.\n        Set ``timeout`` to ``0`` to check if a message was already received.\n        :raises ~websockets.exceptions.ConnectionClosed: when the\n            connection is closed\n        :raises asyncio.CancelledError: if the websocket closes while waiting\n        :raises ServerError: if two tasks call :meth:`recv` or\n            :meth:`recv_streaming` concurrently\n        "
    config_0 = module_0.Config()
    none_type_0 = config_0.__setitem__(str_0, str_0)


def test_case_13():
    config_0 = module_0.Config()
    none_type_0 = config_0.update(**config_0)


def test_case_14():
    str_0 = "R!Zo5>W7D.#71yS%\t/P"
    none_type_0 = None
    module_0.Config(keep_alive=none_type_0, converters=str_0)


def test_case_15():
    str_0 = "R!Zo5>W7D.#7`yS%\t/P"
    str_1 = "_"
    var_0 = module_2.isdatadescriptor(str_0)
    config_0 = module_0.Config(env_prefix=str_1, keep_alive=var_0)
    var_1 = config_0.update_config(config_0)
    var_2 = var_1.__repr__()
    config_1 = module_0.Config()
    none_type_0 = var_1.__bool__()
    none_type_1 = None
    none_type_2 = config_1.register_type(none_type_1)
    config_1.update_config(none_type_2)
