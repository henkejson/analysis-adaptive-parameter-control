# Test cases automatically generated by Pynguin (https://www.pynguin.eu).
# Please check them before you use them.
import flutils.namedtupleutils as module_0
import collections as module_1


def test_case_0():
    complex_0 = 2722 + 1879.9478234267542j
    module_0.to_namedtuple(complex_0)


def test_case_1():
    bool_0 = False
    str_0 = "Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    "
    tuple_0 = (bool_0, str_0, bool_0)
    dict_0 = {tuple_0: bool_0, tuple_0: str_0, str_0: str_0}
    bytes_0 = b"s.\xbb\xe0\xae\xbbd\x08j"
    tuple_1 = (dict_0, bytes_0, bool_0, bool_0)
    var_0 = module_0.to_namedtuple(tuple_1)


def test_case_2():
    str_0 = "convert_escaped_unicode_literal"
    dict_0 = {str_0: str_0, str_0: str_0}
    var_0 = module_0.to_namedtuple(dict_0)


def test_case_3():
    ordered_dict_0 = module_1.OrderedDict()
    var_0 = module_0.to_namedtuple(ordered_dict_0)


def test_case_4():
    str_0 = ""
    module_0.to_namedtuple(str_0)


def test_case_5():
    list_0 = []
    var_0 = module_0.to_namedtuple(list_0)


def test_case_6():
    dict_0 = {}
    var_0 = module_0.to_namedtuple(dict_0)


def test_case_7():
    str_0 = ""
    tuple_0 = (str_0,)
    var_0 = module_0.to_namedtuple(tuple_0)


def test_case_8():
    ordered_dict_0 = module_1.OrderedDict()
    var_0 = module_0.to_namedtuple(ordered_dict_0)
    var_1 = module_0.to_namedtuple(var_0)


def test_case_9():
    tuple_0 = ()
    var_0 = module_0.to_namedtuple(tuple_0)


def test_case_10():
    str_0 = "convert_escaped_unicode_literal"
    dict_0 = {str_0: str_0, str_0: str_0}
    var_0 = module_0.to_namedtuple(dict_0)
    var_1 = module_0.to_namedtuple(var_0)


def test_case_11():
    str_0 = "convert_escaped_unicode_literal"
    dict_0 = {str_0: str_0, str_0: str_0}
    ordered_dict_0 = module_1.OrderedDict(**dict_0)
    var_0 = module_0.to_namedtuple(ordered_dict_0)
    bytes_0 = b"\xbd\xb5\xd1\x16\xba"
    dict_1 = {
        var_0: var_0,
        var_0: var_0,
        var_0: ordered_dict_0,
        var_0: bytes_0,
        bytes_0: ordered_dict_0,
    }
    module_0.to_namedtuple(dict_1)


def test_case_12():
    str_0 = "convert_escaped_anicode_itera "
    dict_0 = {str_0: str_0, str_0: str_0}
    var_0 = module_0.to_namedtuple(dict_0)
    ordered_dict_0 = module_1.OrderedDict(**dict_0)
    var_1 = module_0.to_namedtuple(ordered_dict_0)
    module_1.OrderedDict(**var_0)
