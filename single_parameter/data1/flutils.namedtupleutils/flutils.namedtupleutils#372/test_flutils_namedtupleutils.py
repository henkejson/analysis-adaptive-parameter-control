# Test cases automatically generated by Pynguin (https://www.pynguin.eu).
# Please check them before you use them.
import flutils.namedtupleutils as module_0
import collections as module_1


def test_case_0():
    bool_0 = True
    module_0.to_namedtuple(bool_0)


def test_case_1():
    str_0 = "Lv\n:1nD\tz#KmUMJ3Z$NB"
    bool_0 = True
    tuple_0 = (str_0, str_0, bool_0)
    var_0 = module_0.to_namedtuple(tuple_0)


def test_case_2():
    bool_0 = True
    dict_0 = {bool_0: bool_0, bool_0: bool_0}
    var_0 = module_0.to_namedtuple(dict_0)


def test_case_3():
    ordered_dict_0 = module_1.OrderedDict()
    var_0 = module_0.to_namedtuple(ordered_dict_0)


def test_case_4():
    str_0 = "yrax3,\x0b\x0bOZ"
    module_0.to_namedtuple(str_0)


def test_case_5():
    list_0 = []
    var_0 = module_0.to_namedtuple(list_0)


def test_case_6():
    dict_0 = {}
    var_0 = module_0.to_namedtuple(dict_0)


def test_case_7():
    ordered_dict_0 = module_1.OrderedDict()
    var_0 = module_0.to_namedtuple(ordered_dict_0)
    var_1 = module_0.to_namedtuple(var_0)


def test_case_8():
    tuple_0 = ()
    var_0 = module_0.to_namedtuple(tuple_0)


def test_case_9():
    str_0 = "caitalze"
    dict_0 = {str_0: str_0, str_0: str_0}
    var_0 = module_0.to_namedtuple(dict_0)
    tuple_0 = (var_0, var_0, var_0)
    bool_0 = False
    tuple_1 = (tuple_0, dict_0, bool_0, var_0)
    var_1 = module_0.to_namedtuple(tuple_1)


def test_case_10():
    bytes_0 = b"\xf5y\xa0G\x9d\xf7\x86\x10\xda\x90\x11F"
    bool_0 = True
    tuple_0 = (bytes_0, bool_0)
    dict_0 = {tuple_0: bytes_0, tuple_0: tuple_0, bytes_0: bytes_0}
    module_0.to_namedtuple(dict_0)


def test_case_11():
    str_0 = "kN=="
    str_1 = "caitalze"
    dict_0 = {str_0: str_0, str_1: str_0}
    var_0 = module_0.to_namedtuple(dict_0)
    list_0 = [str_0, str_0, str_0, dict_0]
    tuple_0 = (var_0, list_0, var_0)
    bool_0 = False
    tuple_1 = (tuple_0, dict_0, bool_0, var_0)
    var_1 = module_0.to_namedtuple(tuple_1)
    module_1.namedtuple(str_0, str_0, rename=str_0, defaults=str_0, module=str_0)


def test_case_12():
    str_0 = "e\x0b"
    dict_0 = {str_0: str_0, str_0: str_0}
    ordered_dict_0 = module_1.OrderedDict(**dict_0)
    var_0 = module_0.to_namedtuple(ordered_dict_0)
    str_1 = 'Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            """This is the mymodule docstring."""\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            """This is the mymodule docstring."""\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                \'mymodule.mysubmoduleone\',\n                \'mymodule.mysubmoduletwo,two\',\n                \'mymodule.mysubmodulethree:afunction\',\n                \'mymodule.mysubmodulethree:anotherfunction,anotherfuc\'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get(\'mymodule.mysubmodulethree\')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    '
    module_1.namedtuple(str_1, str_1, defaults=str_1)
