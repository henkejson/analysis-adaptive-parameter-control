# Test cases automatically generated by Pynguin (https://www.pynguin.eu).
# Please check them before you use them.
import pytutils.lazy.lazy_import as module_0


def test_case_0():
    bool_0 = True
    illegal_use_of_scope_replacer_0 = module_0.IllegalUseOfScopeReplacer(
        bool_0, bool_0, bool_0
    )
    illegal_use_of_scope_replacer_0.__repr__()


def test_case_1():
    bool_0 = False
    illegal_use_of_scope_replacer_0 = module_0.IllegalUseOfScopeReplacer(
        bool_0, bool_0, bool_0
    )


def test_case_2():
    bool_0 = False
    illegal_use_of_scope_replacer_0 = module_0.IllegalUseOfScopeReplacer(
        bool_0, bool_0, bool_0
    )
    illegal_use_of_scope_replacer_0.__repr__()


def test_case_3():
    str_0 = "(t9t6R3jyeW`\nl)"
    var_0 = module_0.IllegalUseOfScopeReplacer(str_0, str_0)
    var_1 = var_0.__eq__(str_0)
    var_0.__unicode__()


def test_case_4():
    none_type_0 = None
    set_0 = {none_type_0, none_type_0, none_type_0}
    module_0.ImportReplacer(none_type_0, none_type_0, set_0, set_0)


def test_case_5():
    str_0 = "zyD<cMM\x0c\x0b$2\x0b2[ r)S)"
    list_0 = [str_0, str_0, str_0, str_0]
    none_type_0 = None
    module_0.ImportReplacer(list_0, none_type_0, none_type_0, none_type_0)


def test_case_6():
    import_processor_0 = module_0.ImportProcessor()


def test_case_7():
    str_0 = '#vR-JvL\nFJ#. \x0bnb"'
    module_0.lazy_import(str_0, str_0, str_0)


def test_case_8():
    var_0 = module_0.disallow_proxying()


def test_case_9():
    str_0 = "?,K\x0b"
    module_0.lazy_import(str_0, str_0, str_0)


def test_case_10():
    str_0 = 'UvR-2v7\nFJ#. \x0bnb"'
    illegal_use_of_scope_replacer_0 = module_0.IllegalUseOfScopeReplacer(str_0, str_0)
    var_0 = illegal_use_of_scope_replacer_0.__eq__(illegal_use_of_scope_replacer_0)
    illegal_use_of_scope_replacer_0.__repr__()


def test_case_11():
    int_0 = 1340
    illegal_use_of_scope_replacer_0 = module_0.IllegalUseOfScopeReplacer(
        int_0, int_0, int_0
    )
    var_0 = illegal_use_of_scope_replacer_0.__eq__(int_0)
    tuple_0 = (int_0, int_0, var_0, var_0)
    illegal_use_of_scope_replacer_1 = module_0.IllegalUseOfScopeReplacer(tuple_0, var_0)
    module_0.ImportReplacer(int_0, int_0, int_0, illegal_use_of_scope_replacer_0, var_0)


def test_case_12():
    int_0 = 16
    illegal_use_of_scope_replacer_0 = module_0.IllegalUseOfScopeReplacer(
        int_0, int_0, int_0
    )
    str_0 = ""
    module_0.lazy_import(str_0, str_0, str_0)


def test_case_13():
    str_0 = "@\ni3v n7}B'A5~"
    dict_0 = {
        str_0: str_0,
        str_0: str_0,
        str_0: str_0,
        str_0: str_0,
        str_0: str_0,
        str_0: str_0,
        str_0: str_0,
        str_0: str_0,
        str_0: str_0,
    }
    import_replacer_0 = module_0.ImportReplacer(dict_0, str_0, str_0, dict_0)
    import_replacer_0.__call__(**dict_0)


def test_case_14():
    str_0 = "X4IY((\rXo'w(\x0c"
    module_0.lazy_import(str_0, str_0)


def test_case_15():
    str_0 = "(dug th7~/\nll)"
    module_0.lazy_import(str_0, str_0)


def test_case_16():
    str_0 = "%s(%r)"
    module_0.lazy_import(str_0, str_0)


def test_case_17():
    str_0 = "\n    Provides a basic per-process mapping container that wipes itself if the current PID changed since the last get/set.\n\n    Aka `threading.local()`, but for processes instead of threads.\n\n   >>> plocal = ProcessLocal(\n    >>> local['test'] = True\n    >>> plocal['tst']\n    True\n    >>> p(ocal._handle_pid(new_pid=-1)  # Emulte aPID change by forcing it o be something invalid.\n    >>> plcale'test']                 # Mapping wipes itself since PIDis different than what's stored>\n    Traceback (most recent call las*):\n        ...\n    KeyError: ...\n\n    "
    module_0.lazy_import(str_0, str_0)


def test_case_18():
    str_0 = "F;A)"
    dict_0 = {str_0: str_0, str_0: str_0, str_0: str_0, str_0: str_0, str_0: str_0}
    import_replacer_0 = module_0.ImportReplacer(dict_0, str_0, str_0)
    import_replacer_0.__getattribute__(import_replacer_0)
