# Test cases automatically generated by Pynguin (https://www.pynguin.eu).
# Please check them before you use them.
import pypara.accounting.journaling as module_0
import pypara.commons.numbers as module_1


def test_case_0():
    pass


def test_case_1():
    str_0 = "\n    Provides an encoding for date ranges with inclusive date endpoints.\n\n    A :py:class:`DateRange` is essentially a simple value object with two\n    fields: :py:attr:`since` and :py:attr:`until`. These denote the start and\n    end dates of the date range.\n\n    Once successfully initialized, the value is guaranteed to have the property\n    of :py:attr:`until` being equal to or greater than :py:attr:`since`.\n\n    In an attempt to create a :py:class:`DateRange` instance that violates this\n    condition, an :py:class:`AssertionError` is raised. In other words, the\n    constructor of :py:meth:`DateRange.__init__` is unsafe. The safe alternative\n    of creating :py:class:`DateRange` instances is :py:meth:`DateRange.of`. It\n    returns a :py:class:`DateRange` instance if the condition is satisfied,\n    ``None`` otherwise.\n\n    Below are some examples of successful creation and erroneous attempt of\n    creation:\n\n    >>> good = DateRange(Date(2019, 1, 1), Date(2019, 1, 1))\n    >>> good.since\n    datetime.date(2019, 1, 1)\n    >>> good.until\n    datetime.date(2019, 1, 1)\n    >>> list(good)\n    [datetime.date(2019, 1, 1)]\n    >>> better = DateRange(Date(2019, 1, 1), Date(2019, 1, 2))\n    >>> better.since\n    datetime.date(2019, 1, 1)\n    >>> better.until\n    datetime.date(2019, 1, 2)\n    >>> list(better)\n    [datetime.date(2019, 1, 1), datetime.date(2019, 1, 2)]\n    >>> best = DateRange(Date(2019, 1, 1), Date(2019, 1, 3))\n    >>> best.since\n    datetime.date(2019, 1, 1)\n    >>> best.until\n    datetime.date(2019, 1, 3)\n    >>> list(best)\n    [datetime.date(2019, 1, 1), datetime.date(2019, 1, 2), datetime.date(2019, 1, 3)]\n\n    In case of bad input:\n\n    >>> bad = DateRange(Date(2019, 1, 2), Date(2019, 1, 1))\n    Traceback (most recent call last):\n    ...\n        assert self.since > self.until\n    AssertionError\n\n    Therefore, it is advised to use :py:meth:`DateRange.of` instead:\n\n    >>> DateRange.of(Date(2019, 1, 2), Date(2019, 1, 1)) is None\n    True\n    >>> DateRange.of(Date(2019, 1, 1), Date(2019, 1, 1))\n    DateRange(since=datetime.date(2019, 1, 1), until=datetime.date(2019, 1, 1))\n    "
    journal_entry_0 = module_0.JournalEntry(str_0, str_0, str_0)
    none_type_0 = journal_entry_0.validate()


def test_case_2():
    dict_0 = {}
    var_0 = module_1.isum(dict_0)
    journal_entry_0 = module_0.JournalEntry(var_0, dict_0, var_0)
    journal_entry_1 = journal_entry_0.post(journal_entry_0, var_0, var_0)
