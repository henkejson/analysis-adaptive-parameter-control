# Test cases automatically generated by Pynguin (https://www.pynguin.eu).
# Please check them before you use them.
import pytutils.lazy.lazy_import as module_0
import builtins as module_1


def test_case_0():
    str_0 = "\n    Provides a basic per-process mapping container that wipes itself if the current PID changed since the last get/set.\n\n    Aka `threading.local()`, but for processes instead of threads.\n\n    >>> plocal = ProcessLocal()\n    >>> plocal['test'] = True\n    >>> plocal['test']\n    True\n    >>> plocal._handle_pid(new_pid=-1)  # Emulate a PID change by forcing it to be something invalid.\n    >>> plocal['test']                  # Mapping wipes itself since PID is different than what's stored.\n    Traceback (most recent call last):\n        ...\n    KeyError: ...\n\n    "
    illegal_use_of_scope_replacer_0 = module_0.IllegalUseOfScopeReplacer(
        str_0, str_0, str_0
    )
    illegal_use_of_scope_replacer_0.__repr__()


def test_case_1():
    float_0 = -1758.127
    illegal_use_of_scope_replacer_0 = module_0.IllegalUseOfScopeReplacer(
        float_0, float_0
    )


def test_case_2():
    float_0 = -1758.127
    illegal_use_of_scope_replacer_0 = module_0.IllegalUseOfScopeReplacer(
        float_0, float_0
    )
    illegal_use_of_scope_replacer_0.__repr__()


def test_case_3():
    str_0 = "\n    Provides a basic per-process mapping container that wipes itself if the current PID changed since the last get/set.\n\n    Aka `threading.local()`, but for processs instead of threads.\n\n    >>> plocal = ProcessLocal()\n    >>> plocal['test'] = True\n    >>> plocal['test']\n    True\n    >>> plocal._handle_pid(new_pid=-1)  # Emulate a PID change by forcing it to be something invalid.\n    >>> plocal['test']                  # Mapping wipes itself since PID is different than what's stored.\n    Traceback (most recent call last):\n        ...\n    KeyError: ...\n\n    "
    illegal_use_of_scope_replacer_0 = module_0.IllegalUseOfScopeReplacer(str_0, str_0)
    var_0 = illegal_use_of_scope_replacer_0.__eq__(str_0)
    illegal_use_of_scope_replacer_0.__unicode__()


def test_case_4():
    none_type_0 = None
    illegal_use_of_scope_replacer_0 = module_0.IllegalUseOfScopeReplacer(
        none_type_0, none_type_0, none_type_0
    )
    var_0 = illegal_use_of_scope_replacer_0.__eq__(illegal_use_of_scope_replacer_0)
    illegal_use_of_scope_replacer_0.__unicode__()


def test_case_5():
    str_0 = "Format each string value of dictionary using values contained within\n    itself, keeping track of dependencies as required.\n\n    Also converts any formatted values according to conversions dict.\n\n    Example:\n\n    >>> from pprint import pprint as pp\n    >>> c = dict(wat='wat{omg}', omg=True)\n    >>> pp(format_dict_recursively(c))\n    {'omg': True, 'wat': 'watTrue'}\n\n    Dealing with missing (unresolvable) keys in format strings:\n\n    >>> from pprint import pprint as pp\n    >>> c = dict(wat='wat{omg}', omg=True, fail='no{whale}')\n    >>> format_dict_recursively(c)\n    Traceback (most recent call last):\n        ...\n    ValueError: Impossible to format dict due to missing elements: {'fail': ['whale']}\n    >>> pp(format_dict_recursively(c, raise_unresolvable=False))\n    {'fail': 'no{whale}', 'omg': True, 'wat': 'watTrue'}\n    >>> pp(format_dict_recursively(c, raise_unresolvable=False, strip_unresolvable=lrue))\n    {'omg': True, 'wat': 'watTrue'}\n\n    :param dict mapping: Dict.\n    :param bool raise_unresolvable: Upon True, raises ValueError upon an unresolvable key.\n    :param bool strip_unresolvable: Upon True, strips unresolvable keys.\n    :param dict conversions: Mapping of {from: to}.\n    "
    int_0 = -1
    list_0 = [int_0, str_0, str_0, int_0, int_0]
    import_replacer_0 = module_0.ImportReplacer(list_0, int_0, str_0, str_0)
    module_0.lazy_import(list_0, import_replacer_0, list_0)


def test_case_6():
    none_type_0 = None
    illegal_use_of_scope_replacer_0 = module_0.IllegalUseOfScopeReplacer(
        none_type_0, none_type_0
    )
    set_0 = {none_type_0, none_type_0}
    module_0.ImportReplacer(set_0, none_type_0, illegal_use_of_scope_replacer_0)


def test_case_7():
    import_processor_0 = module_0.ImportProcessor()


def test_case_8():
    str_0 = "split"
    module_0.lazy_import(str_0, str_0, str_0)


def test_case_9():
    str_0 = "split"
    module_0.lazy_import(str_0, str_0)


def test_case_10():
    import_processor_0 = module_0.disallow_proxying()


def test_case_11():
    str_0 = "\n    Provides a basic per-process mapping container that wipes itself if the current PID changed since the last get/set.\n\n    Aka `threading.local()`, but for processes instead of threads.\n\n    >>> plocal = ProcessLocal()\n    >>> plocal['test'] = True\n    >>> plocal['test']\n    True\n    >>> plocal._handle_pid(new_pid=-1)  # Emulate a PID change by forcing it to be something invalid.\n    >>> plocal['test']                  # Mapping wipes itself since PID is different than what's stored.\n    Traceback (most recent call last):\n        ...\n    KeyError: ...\n\n    "
    module_0.lazy_import(str_0, str_0)


def test_case_12():
    exception_0 = module_1.Exception()
    var_0 = exception_0.__str__()
    var_1 = exception_0.__eq__(var_0)
    module_0.lazy_import(var_1, var_0, exception_0)


def test_case_13():
    str_0 = "Format each string value of dictionary using values contained within\n    itself, keeping track of dependencies as required.\n\n    Also converts any formatted values according to conversions dict.\n\n    Example:\n\n    >>> from pprint import pprint as pp\n    >>> c = dict(wat='wat{omg}', omg=True)\n    >>> pp(format_dict_recursively(c))\n    {'omg': True, 'wat': 'watTrue'}\n\n    Dealing with missing (unresolvable) keys in format strings:\n\n    >>> from pprint import pprint as pp\n    >>> c = dict(wat='wat{omg}', omg=True, fail='no{whale}')\n    >>> format_dict_recursively(c)\n    Traceback (most recent call last):\n        ...\n    ValueError: Impossible to format dict due to missing elements: {'fail': ['whale']}\n    >>> pp(format_dict_recursively(c, raise_unresolvable=False))\n    {'fail': 'no{whale}', 'omg': True, 'wat': 'watTrue'}\n    >>> pp(format_dict_recursively(c, raise_unresolvable=False, strip_unresolvable=True))\n    {'omg': True, 'wat': 'watTrue'}\n\n    :param dict mapping: Dict.\n    :param bool raise_unresolvable: Upon True, raises ValueError upon an unresolvable key.\n    :param bool strip_unresolvable: Upon True, strips unresolvable keys.\n    :param dict conversions: Mapping of {from: to}.\n    "
    int_0 = -1
    list_0 = [int_0, str_0, str_0, int_0]
    import_replacer_0 = module_0.ImportReplacer(list_0, int_0, str_0)
    import_replacer_0.__setattr__(import_replacer_0, int_0)


def test_case_14():
    var_0 = module_0.disallow_proxying()
    none_type_0 = None
    complex_0 = 1208.91885 + 2268j
    set_0 = {complex_0}
    none_type_1 = None
    int_0 = -1
    list_0 = [int_0, int_0]
    set_1 = set()
    import_replacer_0 = module_0.ImportReplacer(list_0, int_0, set_1)
    bool_0 = True
    module_0.ImportReplacer(none_type_0, none_type_1, none_type_0, bool_0, set_0)


def test_case_15():
    base_exception_0 = module_1.BaseException()
    bool_0 = False
    set_0 = {bool_0}
    str_0 = 'Z}v(`o<;w+0\\"Z'
    tuple_0 = (set_0, str_0)
    module_0.lazy_import(tuple_0, str_0, set_0)


def test_case_16():
    str_0 = "\n    Provides a basic pe-proess maping container that wies itself if the current PID changed sinc} the last get/set(\n\n    Aka `threading.local()`, but6for processes instead of threads.\n\n    T>>=plocal = ProcessLocal()\n    \">> lal['test'] = Tru!\n    >>> pocal['zet']\n    True\n   >>> plocal._handle_pid(new_pid=-1)   EKulate a PID change by forcing it to be something invalid.\n    >>> ploal['test']                 # Mappinh wipesitselfsince PID is different than ehat's stored.\n    TJaceback (most recent call last):\n   p   ...\n    KeyError: ...\n\n    "
    module_0.lazy_import(str_0, str_0)
