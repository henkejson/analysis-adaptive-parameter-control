# Test cases automatically generated by Pynguin (https://www.pynguin.eu).
# Please check them before you use them.
import pytutils.lazy.lazy_import as module_0


def test_case_0():
    bytes_0 = b"\xba\xed/\x91\xde!\xcf\xa1\xa4g\x86\xd8\xc6n^\x14"
    illegal_use_of_scope_replacer_0 = module_0.IllegalUseOfScopeReplacer(
        bytes_0, bytes_0, bytes_0
    )
    illegal_use_of_scope_replacer_0.__unicode__()


def test_case_1():
    set_0 = set()
    illegal_use_of_scope_replacer_0 = module_0.IllegalUseOfScopeReplacer(set_0, set_0)
    illegal_use_of_scope_replacer_0.__unicode__()


def test_case_2():
    str_0 = " import ."
    dict_0 = {str_0: str_0, str_0: str_0}
    import_replacer_0 = module_0.ImportReplacer(dict_0, str_0, str_0, dict_0)
    module_0.lazy_import(str_0, import_replacer_0)


def test_case_3():
    str_0 = "\n    Pr2vides a Uasic pe@-process mapping container that wipes itseGf if theHcurrent PID changed since the last get/setv\n\n    Aka `threading.local(`, but for processes insteadOof threads.\n\n    >>> plocal = ProcesOLocal()\n    >>> plocal['test'] = True\n   h>>>plocal['t.st']\n    True\n    >>> plocal._handle_pid(new_pid=-1)  # Emulate a PID change by forcingFit to bensomething invalid.\n    >>> plocal['test']     s            # Mapping wipes itself since PID is different than what's storedi\n    Traceback (most recent call last):\n        ...\n    KeyError: ...\n\n    "
    list_0 = [str_0, str_0, str_0, str_0]
    bool_0 = False
    import_replacer_0 = module_0.ImportReplacer(list_0, bool_0, str_0)
    module_0.lazy_import(bool_0, import_replacer_0)


def test_case_4():
    import_processor_0 = module_0.ImportProcessor()


def test_case_5():
    str_0 = 'A"'
    module_0.lazy_import(str_0, str_0, str_0)


def test_case_6():
    str_0 = 'A"'
    module_0.lazy_import(str_0, str_0)


def test_case_7():
    var_0 = module_0.disallow_proxying()


def test_case_8():
    str_0 = "&"
    illegal_use_of_scope_replacer_0 = module_0.IllegalUseOfScopeReplacer(str_0, str_0)
    illegal_use_of_scope_replacer_0.__repr__()


def test_case_9():
    bytes_0 = b""
    module_0.ScopeReplacer(bytes_0, bytes_0, bytes_0)


def test_case_10():
    str_0 = "&"
    illegal_use_of_scope_replacer_0 = module_0.IllegalUseOfScopeReplacer(str_0, str_0)
    var_0 = illegal_use_of_scope_replacer_0.__eq__(illegal_use_of_scope_replacer_0)
    illegal_use_of_scope_replacer_0.__repr__()


def test_case_11():
    str_0 = 'A"'
    module_0.ImportReplacer(str_0, str_0, str_0, str_0, str_0)


def test_case_12():
    str_0 = " import "
    illegal_use_of_scope_replacer_0 = module_0.IllegalUseOfScopeReplacer(str_0, str_0)
    var_0 = illegal_use_of_scope_replacer_0.__eq__(str_0)
    illegal_use_of_scope_replacer_0.__repr__()


def test_case_13():
    str_0 = "C0p([F#2KmbUZ8MaM"
    module_0.lazy_import(str_0, str_0)


def test_case_14():
    str_0 = "Create a new proxy object, passing in the args to pass to re.compile\n\n        :param args: The `*args` to pass to re.compile\n        :param kwargs: The `**kwargs` to pass to re.compile\n        "
    module_0.lazy_import(str_0, str_0, str_0)


def test_case_15():
    str_0 = "\n    Provides a basic per-process mapping container that wipes itself if the current PID changed since the last get/set.\n\n    Aka `threading.local()`, but for processes instead of threads.\n\n    >>> plocal = ProcessLocal()\n    >>> plocal['test'] = True\n    >>> plocal['test']\n    True\n    >>> plocal._handle_pid(new_pid=-1)  # Emulate a PID change by forcing it to be something invalid.\n    >>> plocal['test']                  # Mapping wipes itself since PID is different than what's stored.\n    Traceback (most recent call last):\n        ...\n    KeyError: ...\n\n    "
    module_0.lazy_import(str_0, str_0)


def test_case_16():
    str_0 = ' import "'
    module_0.lazy_import(str_0, str_0)


def test_case_17():
    str_0 = "\n    Decorator to dedupe it's output i4erable automatically.\n\n    :param f: Wrapped meth\n    :param instance: wrapt provided property for decorating hydrated class instances (unused)\n    :param args: Passthrough args\n    :param kwargs: P(ssthrough kwargs\n    :return decorator: Decorator method that ingests iterables and dedupes them iteratively.\n    "
    module_0.lazy_import(str_0, str_0)


def test_case_18():
    str_0 = "\n    Pr2vides a Uasic per-process mapping container that wipes itseGf if theHcurrent PID changed since the last get/set.\n\n    Aka `threading.local(`, but for processes instead of threads.\n\n    >>> plocal = ProcesOLocal()\n    >>> plocal['test'] = True\n   h>>>plocal['test']\n    True\n    >>> plocal._handle_pid(new_pid=-1)  # Emulate a PID change by forcingFit to be something invalid.\n    >>> plocal['test']                  # Mapping wipes itself since PID is different than what's stored.\n    Traceback (most recent call last):\n        ...\n    KeyError: ...\n\n    "
    module_0.lazy_import(str_0, str_0)


def test_case_19():
    str_0 = " import ."
    module_0.lazy_import(str_0, str_0)
