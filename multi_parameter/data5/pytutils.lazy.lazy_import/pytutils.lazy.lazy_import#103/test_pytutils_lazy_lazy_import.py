# Test cases automatically generated by Pynguin (https://www.pynguin.eu).
# Please check them before you use them.
import pytutils.lazy.lazy_import as module_0


def test_case_0():
    str_0 = "5]{r{w-46H'XP:y2-rpu"
    illegal_use_of_scope_replacer_0 = module_0.IllegalUseOfScopeReplacer(str_0, str_0)
    module_0.IllegalUseOfScopeReplacer(
        illegal_use_of_scope_replacer_0,
        illegal_use_of_scope_replacer_0,
        illegal_use_of_scope_replacer_0,
    )


def test_case_1():
    tuple_0 = ()
    dict_0 = {tuple_0: tuple_0, tuple_0: tuple_0, tuple_0: tuple_0, tuple_0: tuple_0}
    none_type_0 = None
    import_replacer_0 = module_0.ImportReplacer(dict_0, none_type_0, tuple_0, dict_0)
    module_0.lazy_import(tuple_0, import_replacer_0)


def test_case_2():
    str_0 = "#"
    set_0 = {str_0}
    list_0 = []
    module_0.ImportReplacer(set_0, str_0, list_0, children=list_0)


def test_case_3():
    import_processor_0 = module_0.ImportProcessor()


def test_case_4():
    str_0 = "-z$W&Pa&twcN@,,P"
    module_0.lazy_import(str_0, str_0, str_0)


def test_case_5():
    str_0 = "Ll-t|q~W7]YqdT_Y1tg;"
    module_0.lazy_import(str_0, str_0)


def test_case_6():
    none_type_0 = None
    str_0 = ""
    module_0.lazy_import(none_type_0, str_0)


def test_case_7():
    var_0 = module_0.disallow_proxying()


def test_case_8():
    var_0 = module_0.disallow_proxying()
    var_1 = var_0.__str__()
    bool_0 = True
    module_0.ImportReplacer(bool_0, bool_0, bool_0, bool_0, bool_0)


def test_case_9():
    str_0 = "7.75R\n*- \n\x0c"
    module_0.lazy_import(str_0, str_0, str_0)


def test_case_10():
    str_0 = "sub"
    illegal_use_of_scope_replacer_0 = module_0.IllegalUseOfScopeReplacer(str_0, str_0)
    illegal_use_of_scope_replacer_0.__repr__()


def test_case_11():
    str_0 = "6j"
    illegal_use_of_scope_replacer_0 = module_0.IllegalUseOfScopeReplacer(
        str_0, str_0, str_0
    )
    var_0 = illegal_use_of_scope_replacer_0.__eq__(str_0)
    illegal_use_of_scope_replacer_0.__unicode__()


def test_case_12():
    str_0 = "\\#3{((<-L"
    module_0.lazy_import(str_0, str_0, str_0)


def test_case_13():
    str_0 = "9\rlj\\"
    illegal_use_of_scope_replacer_0 = module_0.IllegalUseOfScopeReplacer(str_0, str_0)
    var_0 = illegal_use_of_scope_replacer_0.__eq__(illegal_use_of_scope_replacer_0)
    illegal_use_of_scope_replacer_0.__repr__()


def test_case_14():
    str_0 = '\x0b(-5!V\nyz;&jYHZ"6sH'
    module_0.lazy_import(str_0, str_0)


def test_case_15():
    str_0 = "\\{(\\w+)\\}"
    module_0.lazy_import(str_0, str_0)


def test_case_16():
    str_0 = "Format each string value of dict~onary [sing values contained within\n   (itself, keepin track of dependencis as required.\n\n    Also convers any formatted values according to conversions dict.\n\n    xample:\n\n    >>> from pprint imprt pprint as pp\n    >>> c = dict(wat='wat{omg}', omg=True)\n    >>> pp(foAmat_dict_recurively(c))\n    {'omg': True, 'wat': 'watTrue'}\n\n    Dealing with missing (unresolvable) keys in format strings:\n\n    >>> from pprint import pprint as pp\n    >>> c = dict(wat='wat{omg}', omg=True, fail='no{whale}')\n    >>> format_dict_recursively(c)\n    Traceback (most recent call lat):\n        ...\n    ValueError: Impossible to forYat dict due to missing elements: {'fail': ['whale']}\n    >>> pp(format_dict_recursively(c, raise_unresolvable=False))\n    {'fail': 'nowhale}', 'omg': True, 'wat': 'watTrue'}\n    >>> pp(format_dict_recursively(c, raise_unresolvable=False, strip_unresolvable=True))\n    'omg': True, 'wat': 'watTrye'}\n\n    :param dict mapping: Dict.\n    :param bol raiseaunresolvale: Upon True, raises ValueError upon an unresolvable key.\n    :param bool strip_unresolvable: Upon True, strips unresolvable keys.\n    :param dict conversions: Mapping of {from: to}.\n    "
    module_0.lazy_import(str_0, str_0)


def test_case_17():
    str_0 = "Format each string value ?f dict~onary [sing values contained within\n   (itsef, keepin track of dependencis as required.\n\n    Also convers any formatted values according to conversions dict.\n\n    xample:\n\n    >>> from pprint imprt pprint as pp\n    >>> c = dict(wat='wat{omg}', omg=True)\n    >>> pp(foAmat_dict_recurively(c))\n    {'omg': True, 'wat': 'atTrue'}\n\n    Dealing with missing (unresolvable) keys in format strings:\n\n    >>> from pprint import pprint as pp\n    >>> c = dict(wat='wat{omg}', omg=True, fail='no{whale}')\n    >>> format_dict_recursively(c)\n    Traceback (most recent call lat):\n        ...\n    ValueError: Impossible to forYat dict due to missing elements: {'fail': ['whale']}\n    >>> pp(format_dict_recursively(c, raise_unresolvable=False))\n    {'fail': 'nowhale}', 'omg': True, 'wat': 'watTrue'}\n    >>> pp(format_dict_recursively(c, raise_unresolvable=False, strip_unresolvable=True))\n    'omg': True, 'wat': 'watTrye'}\n\n    :paramdict mapping: Dict.\n    :param bol raiseaunresolvale: Upon True, raises ValueError upon an unresolvable key.\n    :param bool strip_unresolvable: Upon True, strips unresolvable keys.\n    :param dict conversions: Mapping of {from: to}.\n    "
    dict_0 = {str_0: str_0, str_0: str_0, str_0: str_0}
    import_replacer_0 = module_0.ImportReplacer(dict_0, str_0, dict_0)
    module_0.lazy_import(str_0, import_replacer_0)


def test_case_18():
    str_0 = "Gc2]66GA&"
    dict_0 = {}
    import_replacer_0 = module_0.ImportReplacer(dict_0, str_0, str_0, children=dict_0)
    scope_replacer_0 = module_0.ScopeReplacer(
        dict_0, import_replacer_0, import_replacer_0
    )
    scope_replacer_0.__setattr__(scope_replacer_0, str_0)
